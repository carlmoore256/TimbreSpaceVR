using UnityEngine;
using System.Collections.Generic;
using System;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;
using System.Collections;

public interface ISequenceObserver
{
    void OnSequenceUpdated(IEnumerable<SequenceItem> sequenceItems);
}

public class Sequence : ISequenceable, IEnumerable<SequenceItem>
{
    public List<SequenceItem> SequenceItems { get; private set; } = new List<SequenceItem>(); // make sure 
    // that this will return an ordered list based on the item's RelativePlayTime
    public int Count => SequenceItems.Count;
    public SequenceItem this[int index] => SequenceItems[index];
    public event Action<SequenceItem> OnSequenceAdvance;

    public RhythmClock Clock { get; private set; } = new RhythmClock();

    private List<ScheduleCancellationToken> _cancellationTokens = new List<ScheduleCancellationToken>();

    public Sequence()
    {
        Clock.OnTempoChanged += CalculatePlayTimes;
        Clock.OnTimeSignatureChanged += CalculatePlayTimes;        
    }


    private void CalculatePlayTimes()
    {
        UnityEngine.Debug.Log("Recalculating Play Times!");
        foreach(var item in SequenceItems)
        {
            if (item.BeatIndex == null) continue;
            item.RelativePlayTime = Clock.TimeFromBeatIndex(item.BeatIndex);
        }
    }
    
    public void AddSequenceable(ISequenceable sequenceable) {
        SequenceItems.Add(new SequenceItem { Sequenceable = sequenceable });
    }

    public void AddSequenceableRange(IEnumerable<ISequenceable> sequenceables) {
        foreach (var sequenceable in sequenceables) {
            SequenceItems.Add(new SequenceItem { Sequenceable = sequenceable });
        }
    }

    public void AddSequenceItem(SequenceItem sequenceItem) {
        SequenceItems.Add(sequenceItem);
    }

    public void AddSequenceableAtTime(ISequenceable sequenceable, double time, float gain=1.0f)
    {
        SequenceItem sequenceItem = new SequenceItem
        {
            Sequenceable = sequenceable,
            RelativePlayTime = time
        };
        SequenceItems.Add(sequenceItem);
    }

    public void AddSequenceableAtBeat(ISequenceable sequenceable, float beat, float gain=1.0f)
    {
        AddSequenceableAtTime(sequenceable, Clock.BeatPositionToTime(beat), gain);
    }

    public void AddSequenceableAtNoteValue(ISequenceable sequenceable, int bar, NoteValue noteValue, int noteValuePosition, float gain=1.0f)
    {
        double time = Clock.TimeFromNotePosition(bar, noteValue, noteValuePosition);
        AddSequenceableAtTime(sequenceable, time, gain);
    }

    public void AddSequenceableAtBeatIndex(ISequenceable sequenceable, BeatIndex beat, SequenceableParameters parameters=null)
    {
        UnityEngine.Debug.Log("Adding sequenceable at beat index " + beat.ToString() + " with time " + Clock.TimeFromBeatIndex(beat).ToString("F3") + " seconds");
        SequenceItem sequenceItem = new SequenceItem
        {
            Sequenceable = sequenceable,
            BeatIndex = beat,
            RelativePlayTime = Clock.TimeFromBeatIndex(beat)
        };
        if (parameters != null) {
            sequenceItem.Parameters = parameters;
        }
        SequenceItems.Add(sequenceItem);
    }



    public void Remove(ISequenceable sequenceable) {
        SequenceItems.RemoveAll(item => item.Sequenceable == sequenceable);
    }

    /// <summary>
    /// Cancel all scheduled events by this sequence
    /// </summary>
    public void Stop()
    {
        foreach(var token in _cancellationTokens) {
            token.Cancel();
        }
    }

    public void Play(float gain=1f)
    {
        Schedule(AudioSettings.dspTime + 0.1d, new SequenceableParameters { Gain = gain });
    }

    private void OrderSequenceItemsByStartTime()
    {
        SequenceItems = SequenceItems.OrderBy(item => item.RelativePlayTime).ToList();
    }


    # region ISequenceable

    public Guid Id { get; protected set; } = Guid.NewGuid();

    // Sequence.Schedule NEVER will generate its own PlaybackEvent, those are generated by 
    // things that will interact with the audio system. Don't confuse the OnSequenceablePlayStart with 
    // a PlaybackEvent that fires events from the audio system. That is ultimately the entry point
    // for any stop/start callback
    public ScheduleCancellationToken Schedule(double time, SequenceableParameters parameters) 
    {
        CalculatePlayTimes();

        List<ScheduleCancellationToken> cancellationTokens = new List<ScheduleCancellationToken>();
        
        // order sequence items by play time
        var sortedSequenceItems = SequenceItems.OrderBy(item => item.RelativePlayTime);
        // filter out any where relativePlayTime is less than 0
        var validSequenceItems = sortedSequenceItems.Where(item => item.RelativePlayTime >= 0);

        var firstScheduledItem = validSequenceItems.FirstOrDefault();
        var lastScheduledItem = validSequenceItems.LastOrDefault();


        // schedule the beginning trigger for this sequence as the earliest play time
        var startToken = new ScheduleCancellationToken(() => {
            UnityEngine.Debug.Log("Cancelling start token");
        });
        cancellationTokens.Add(startToken);

        DSPSchedulerSingleton.Schedule(new ScheduledEvent(
            scheduleTime: time + firstScheduledItem.RelativePlayTime,
            onSchedule: () => OnSequenceablePlayStart?.Invoke(),
            cancellationToken: startToken
        ));

        // schedule the end trigger for this sequence as the last play time
        // double endTime = time + lastScheduledItem.RelativePlayTime;
        // here calculate if there are any SequenceItems with a BeatIndex, and if 
        // so take the last one and make sure that this Sequence's OnSequenceablePlayEnd fires
        // on the final bar

        var lastBar = validSequenceItems.Where(item => item.BeatIndex != null).LastOrDefault()?.BeatIndex.Bar ?? -1;
        double endTime = lastBar == -1 ? time + lastScheduledItem.RelativePlayTime : Clock.TimeFromBars(lastBar + 1);
        
        var endToken = new ScheduleCancellationToken(() => {
            UnityEngine.Debug.Log("Cancelling end token");
        });
        cancellationTokens.Add(endToken);
        
        DSPSchedulerSingleton.Schedule(new ScheduledEvent(
            scheduleTime: endTime,
            onSchedule: () => OnSequenceablePlayEnd?.Invoke(),
            cancellationToken: endToken
        ));


        foreach(var item in validSequenceItems) {

            if (item.RelativePlayTime < 0) continue;

            var token = item.Sequenceable.Schedule(
                time + item.RelativePlayTime, 
                item.Parameters.Merge(parameters)
            );

            Action cb = null;
            cb = () => {
                OnSequenceAdvance?.Invoke(item);
                item.Sequenceable.OnSequenceablePlayStart -= cb;
            };
            item.Sequenceable.OnSequenceablePlayStart += cb;

            // make sure the cancellation token also includes unregistering the OnPlayStart
            token.OnCancel += () => item.Sequenceable.OnSequenceablePlayStart -= cb;

            cancellationTokens.Add(token);
        }

        // wrap these tokens up in a new token
        var sequenceableToken = new ScheduleCancellationToken(() => {
            UnityEngine.Debug.Log("Cancelling sequenceable token");
            foreach(var token in cancellationTokens) {
                token.Cancel();
            }
        });

        _cancellationTokens.Add(sequenceableToken);

        OnSchedule?.Invoke(this, (time, parameters, sequenceableToken));

        return sequenceableToken;
    }

    public event EventHandler<(double, SequenceableParameters, ScheduleCancellationToken)> OnSchedule;
    public event Action OnSequenceablePlayStart;
    public event Action OnSequenceablePlayEnd;
    public void SequenceablePlayStart() {
        OnSequenceablePlayStart?.Invoke();
    }

    public void SequenceablePlayEnd() {
        OnSequenceablePlayEnd?.Invoke();
    }

    # endregion

    private Action _activeLoop = null;
    

    public void Loop() 
    {

        Action loopAction = null;
        loopAction = () => {
            Play();
        };
        OnSequenceablePlayEnd += loopAction;
    }

    public void Loop(int loopCount) 
    {
        int currentLoopCount = 0;
        Action loopAction = null;
        loopAction = () => {
            currentLoopCount++;
            if (currentLoopCount < loopCount) {
                Play();
            } else {
                OnSequenceablePlayEnd -= loopAction;
            }
        };
        OnSequenceablePlayEnd += loopAction;
    }

    public void Loop(float loopTime) 
    {
        double loopEndTime = AudioSettings.dspTime + loopTime;
        Action loopAction = null;
        loopAction = () => {
            if (AudioSettings.dspTime < loopEndTime) {
                Play();
            } else {
                OnSequenceablePlayEnd -= loopAction;
            }
        };
        OnSequenceablePlayEnd += loopAction;
    }

    public void CancelLoop() {
        OnSequenceablePlayEnd -= _activeLoop;
    }


    
    public IEnumerator<SequenceItem> GetEnumerator() {
        return SequenceItems.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}




// private SequenceItem _firstScheduledItem;
// private SequenceItem _lastScheduledItem;

// private Action _sequenceStartHook = null;
// private Action _sequenceEndHook = null;


/// <summary>
/// Hook this sequence's start and end events SequenceablePlayStart() and SequenceablePlayEnd()
/// into the first and last sequenceables in the list
/// </summary>
// private void HookStartAndEnd() {
//     // ----- Hook into the sequenceable's start and end events ---------------
//     // ----- so we can fire our own start and end events for the sequence ----

//     // remove any existing hooks
//     if (_firstScheduledItem != null) {
//         _firstScheduledItem.Sequenceable.OnSequenceablePlayStart -= _sequenceStartHook;
//     }
//     if (_lastScheduledItem != null) {
//         _lastScheduledItem.Sequenceable.OnSequenceablePlayEnd -= _sequenceEndHook;
//     }

//     _firstScheduledItem = SequenceItems.OrderBy(item => item.RelativePlayTime).FirstOrDefault();
//     _lastScheduledItem = SequenceItems.OrderByDescending(item => item.RelativePlayTime).FirstOrDefault();

//     // these actions will unsubscribe themselves once they have run!
//     _sequenceStartHook = () => {
//         UnityEngine.Debug.Log("Sequence.Schedule: seqStart: " + _firstScheduledItem.Sequenceable);
//         _firstScheduledItem.Sequenceable.OnSequenceablePlayStart -= _sequenceStartHook;
//         SequenceablePlayStart();
//     };

//     _sequenceEndHook = () => {
//         UnityEngine.Debug.Log("Sequence.Schedule: seqEnd: " + _lastScheduledItem.Sequenceable);
//         _lastScheduledItem.Sequenceable.OnSequenceablePlayEnd -= _sequenceEndHook;
//         SequenceablePlayEnd();
//     };

//     _firstScheduledItem.Sequenceable.OnSequenceablePlayStart += _sequenceStartHook;
//     _lastScheduledItem.Sequenceable.OnSequenceablePlayEnd += _sequenceEndHook;
// }