using UnityEngine;
using System.Collections.Generic;
using System;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;

public interface ISequenceObserver
{
    void OnSequenceUpdated(IEnumerable<SequenceItem> sequenceItems);
}

public class Sequence : ISequenceable {

    private List<SequenceItem> sequenceItems;
    private List<ISequenceObserver> observers;

    private CancellationTokenSource cancellationTokenSource;
    private Task playbackTask;
    private readonly object syncObj = new object();

    // public event Action OnSequenceStart;
    // public event Action OnSequenceEnd;
    
    public Sequence() {
        sequenceItems = new List<SequenceItem>();
        observers = new List<ISequenceObserver>();
    }

    public void Add(ISequenceable sequenceable, float gain = 1.0f, bool isMuted = false) {
        sequenceItems.Add(new SequenceItem { sequenceable = sequenceable, gain = gain, isMuted = isMuted });
        NotifyObservers();
    }

    public void Add(IEnumerable<ISequenceable> sequenceables, float gain = 1.0f, bool isMuted = false) {
        foreach (var sequenceable in sequenceables) {
            sequenceItems.Add(new SequenceItem { sequenceable = sequenceable, gain = gain, isMuted = isMuted });
        }
        NotifyObservers();
    }

    public void Remove(ISequenceable sequenceable) {
        sequenceItems.RemoveAll(item => item.sequenceable == sequenceable);
        NotifyObservers();
    }

    public void Stop()
    {
        cancellationTokenSource?.Cancel();
    }

    # region ISequenceable

    public int ID { get => 0; }

    
    // Sequence.Schedule NEVER will generate its own PlaybackEvent, those are generated by 
    // things that will interact with the audio system. Don't confuse the OnSequenceablePlayStart with 
    // a PlaybackEvent that fires events from the audio system. That is ultimately the entry point
    // for any stop/start callback
    public void Schedule(SequenceableScheduleParameters parameters) 
    {
        HookStartAndEnd();
        foreach(var item in sequenceItems) {
            item.sequenceable.Schedule(
                new SequenceableScheduleParameters {
                    scheduleTime = parameters.scheduleTime + item.scheduleTime, 
                    gain = item.gain * parameters.gain
                }
            );
        }
    }

    public event EventHandler<SequenceableScheduleParameters> OnSchedule;
    public event Action OnSequenceablePlayStart;
    public event Action OnSequenceablePlayEnd;
    public void SequenceablePlayStart() {
        OnSequenceablePlayStart?.Invoke();
    }

    public void SequenceablePlayEnd() {
        OnSequenceablePlayEnd?.Invoke();
    }

    # endregion

    private SequenceItem firstScheduledItem;
    private SequenceItem lastScheduledItem;

    private Action sequenceStartHook = null;
    private Action sequenceEndHook = null;

    /// <summary>
    /// Hook this sequence's start and end events SequenceablePlayStart() and SequenceablePlayEnd()
    /// into the first and last sequenceables in the list
    /// </summary>
    private void HookStartAndEnd() {
        // ----- Hook into the sequenceable's start and end events ---------------
        // ----- so we can fire our own start and end events for the sequence ----

        // remove any existing hooks
        if (firstScheduledItem != null) {
            firstScheduledItem.sequenceable.OnSequenceablePlayStart -= sequenceStartHook;
        }
        if (lastScheduledItem != null) {
            lastScheduledItem.sequenceable.OnSequenceablePlayEnd -= sequenceEndHook;
        }

        firstScheduledItem = sequenceItems.OrderBy(item => item.scheduleTime).FirstOrDefault();
        lastScheduledItem = sequenceItems.OrderByDescending(item => item.scheduleTime).FirstOrDefault();

        // these actions will unsubscribe themselves once they have run!
        sequenceStartHook = () => {
            UnityEngine.Debug.Log("Sequence.Schedule: seqStart: " + firstScheduledItem.sequenceable);
            firstScheduledItem.sequenceable.OnSequenceablePlayStart -= sequenceStartHook;
            SequenceablePlayStart();
        };

        sequenceEndHook = () => {
            UnityEngine.Debug.Log("Sequence.Schedule: seqEnd: " + lastScheduledItem.sequenceable);
            lastScheduledItem.sequenceable.OnSequenceablePlayEnd -= sequenceEndHook;
            SequenceablePlayEnd();
        };

        firstScheduledItem.sequenceable.OnSequenceablePlayStart += sequenceStartHook;
        lastScheduledItem.sequenceable.OnSequenceablePlayEnd += sequenceEndHook;
    }

    public void SetBPM(float bpm) {
        double beatsPerSecond = (double)bpm / 60d;
        double timePerBeat = 1d / beatsPerSecond;
        double scheduleTime = 0d;
        
        for (int i = 0; i < sequenceItems.Count; i++) {
            sequenceItems[i].SetScheduleTime(scheduleTime);
            scheduleTime += timePerBeat;
            // sequenceItems[i].SetSequenceTime(currentTime, currentTime + timePerBeat);
        }
    }
    
    public void AddObserver(ISequenceObserver observer)
    {
        observers.Add(observer);
    }

    public void RemoveObserver(ISequenceObserver observer)
    {
        observers.Remove(observer);
    }

    // Call this method whenever the sequence is updated
    private void NotifyObservers()
    {
        UnityEngine.Debug.Log("Notifying " + observers.Count + " observers for sequence");
        foreach (var observer in observers)
        {
            UnityEngine.Debug.Log("Notifying observer " + observer);
            observer.OnSequenceUpdated(sequenceItems);
        }
    }
}